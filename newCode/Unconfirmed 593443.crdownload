// ================================================================
// PHASE 2 - TASK 2.1: CONVERSATIONAL RESPONSE SYSTEM
// ================================================================

/**
 * PROBLEM SOLVED:
 * - Old system: Robotic, formal responses lacking personality
 * - New system: Friendly, conversational Max with varied greetings and follow-ups
 * 
 * IMPROVEMENTS:
 * ✅ Friendly greetings that vary by context
 * ✅ Simple language explanations for complex terms
 * ✅ Follow-up suggestions to keep conversation flowing
 * ✅ Natural, human-like personality
 * ✅ Context-aware responses
 */

// ================================================================
// CONVERSATIONAL FORMATTER CLASS
// ================================================================

class ConversationalFormatter {
    constructor() {
        // Varied greetings for different contexts
        this.greetings = {
            general: [
                "Great question! Let me look that up for you.",
                "I'd be happy to help with that!",
                "Excellent choice! Here's what I found:",
                "Thanks for asking! Let me analyze that for you.",
                "Perfect timing for this question! Let me check...",
                "I love helping with financial questions! Here we go:",
                "Let me dive into that for you right away!"
            ],
            stock: [
                "Ah, {topic}! One of the interesting stocks to watch. Let me pull up the latest:",
                "Great pick with {topic}! Here's what's happening:",
                "{topic} has been making moves! Let me show you:",
                "I've been tracking {topic} - here's the current picture:",
                "Perfect choice! {topic} is always worth analyzing. Here's what I see:"
            ],
            crypto: [
                "The crypto market never sleeps! Let me check {topic} for you:",
                "Crypto analysis coming right up for {topic}!",
                "Let's dive into the {topic} data together:",
                "{topic} in the crypto space - always exciting! Here's the breakdown:",
                "I love crypto analysis! Let me show you what's up with {topic}:"
            ],
            portfolio: [
                "I'd love to analyze your portfolio! Let me crunch these numbers:",
                "Portfolio analysis is my specialty! Here's what I found:",
                "Great to see you're tracking your investments! Let me take a look:",
                "Perfect! I enjoy helping people understand their portfolios. Here we go:",
                "Excellent - let's see how your investments are performing!"
            ],
            comparison: [
                "Comparing investments is so important! Let me analyze both for you:",
                "Great idea to compare! Here's how they stack up:",
                "I love comparison questions! Let me break this down:",
                "Smart thinking - comparisons help make better decisions. Here's the analysis:"
            ]
        };

        // Follow-up question templates
        this.followUpTemplates = {
            stock: [
                { text: "What's the technical outlook?", action: { type: "show_technical_analysis", params: { topic: "{topic}" } } },
                { text: "How does it compare to competitors?", action: { type: "show_comparison", params: { topic: "{topic}" } } },
                { text: "Any recent news affecting it?", action: { type: "show_news", params: { topic: "{topic}" } } },
                { text: "Show me historical performance", action: { type: "show_historical", params: { topic: "{topic}" } } }
            ],
            crypto: [
                { text: "What are the key support levels?", action: { type: "show_technical_analysis", params: { topic: "{topic}" } } },
                { text: "How volatile has it been?", action: { type: "show_volatility", params: { topic: "{topic}" } } },
                { text: "Compare with other major cryptos", action: { type: "show_comparison", params: { topic: "{topic}" } } },
                { text: "What's driving the price movement?", action: { type: "show_news", params: { topic: "{topic}" } } }
            ],
            portfolio: [
                { text: "How can I improve diversification?", action: { type: "show_diversification", params: {} } },
                { text: "What are my biggest risk factors?", action: { type: "show_risk_analysis", params: {} } },
                { text: "Which positions are over/underweight?", action: { type: "show_allocation", params: {} } },
                { text: "How does it perform vs benchmarks?", action: { type: "show_benchmark", params: {} } }
            ],
            general: [
                { text: "Can you explain this simply?", action: { type: "explain_simply", params: { topic: "{topic}" } } },
                { text: "What would you recommend for a beginner?", action: { type: "beginner_guide", params: { topic: "{topic}" } } },
                { text: "Are there any alternatives?", action: { type: "show_alternatives", params: { topic: "{topic}" } } },
                { text: "What should I research next?", action: { type: "research_suggestions", params: { topic: "{topic}" } } }
            ]
        };

        // Simple explanations for complex terms
        this.simpleExplanations = {
            'market cap': 'total value of all shares',
            'p/e ratio': 'how expensive the stock is compared to earnings',
            'volatility': 'how much the price swings up and down',
            'support level': 'a price where the stock tends to bounce back up',
            'resistance level': 'a price where the stock tends to get stuck',
            'rsi': 'shows if a stock might be overbought or oversold',
            'moving average': 'the average price over a certain time period',
            'dividend yield': 'how much the company pays you just for owning the stock',
            'beta': 'how much the stock moves compared to the overall market',
            'liquidity': 'how easy it is to buy or sell without affecting the price'
        };
    }

    /**
     * Format a response with conversational elements
     */
    formatResponse(analysis, queryInfo) {
        const response = {
            greeting: this.generateGreeting(queryInfo),
            content: this.processContent(analysis, queryInfo),
            followUpOptions: this.generateFollowUpOptions(queryInfo),
            metadata: {
                conversational: true,
                tone: 'friendly',
                complexity: 'simplified',
                timestamp: new Date().toISOString()
            }
        };

        return response;
    }

    /**
     * Generate context-appropriate greeting
     */
    generateGreeting(queryInfo) {
        const greetingType = this.determineGreetingType(queryInfo);
        const greetings = this.greetings[greetingType] || this.greetings.general;
        
        let greeting = greetings[Math.floor(Math.random() * greetings.length)];
        
        // Replace topic placeholder if present
        if (greeting.includes('{topic}') && queryInfo.topic) {
            greeting = greeting.replace('{topic}', queryInfo.topic);
        }
        
        return greeting;
    }

    /**
     * Determine appropriate greeting type based on query
     */
    determineGreetingType(queryInfo) {
        if (queryInfo.type === 'portfolio') return 'portfolio';
        if (queryInfo.type === 'crypto') return 'crypto';
        if (queryInfo.type === 'stock' || queryInfo.type === 'asset') return 'stock';
        if (queryInfo.type === 'comparison') return 'comparison';
        return 'general';
    }

    /**
     * Process content to make it more conversational
     */
    processContent(analysis, queryInfo) {
        let content = analysis.choices?.[0]?.message?.content || analysis.content || '';
        
        // Simplify technical jargon
        content = this.simplifyJargon(content);
        
        // Add personality touches
        content = this.addPersonalityTouches(content);
        
        // Structure with clear sections
        content = this.structureContent(content);
        
        return content;
    }

    /**
     * Replace technical jargon with simple explanations
     */
    simplifyJargon(content) {
        let simplified = content;
        
        for (const [term, explanation] of Object.entries(this.simpleExplanations)) {
            // Create regex that matches the term but adds explanation
            const regex = new RegExp(`\\b${term}\\b`, 'gi');
            simplified = simplified.replace(regex, `${term} (${explanation})`);
        }
        
        return simplified;
    }

    /**
     * Add conversational personality touches
     */
    addPersonalityTouches(content) {
        let enhanced = content;
        
        // Add encouraging phrases
        const encouragingPhrases = [
            'This is interesting!',
            'Here\'s what I\'m seeing:',
            'The data tells a story:',
            'Let me break this down for you:',
            'Here\'s the key insight:'
        ];
        
        // Add transition phrases for better flow
        enhanced = enhanced.replace(/^##/gm, '📊'); // Replace headers with emojis
        enhanced = enhanced.replace(/\n\n/g, '\n\n' + encouragingPhrases[Math.floor(Math.random() * encouragingPhrases.length)] + ' ');
        
        return enhanced;
    }

    /**
     * Structure content with clear, digestible sections
     */
    structureContent(content) {
        // Split into logical sections
        const sections = content.split(/(?=##|📊)/);
        
        const structuredSections = sections.map(section => {
            const trimmed = section.trim();
            if (!trimmed) return null;
            
            // Identify section type
            const isHeader = trimmed.startsWith('##') || trimmed.startsWith('📊');
            
            if (isHeader) {
                const title = trimmed.replace(/^(##|📊)\s*/, '');
                const content = trimmed.replace(/^[^\n]+\n/, '');
                
                return {
                    type: 'section',
                    title: title,
                    content: content.trim()
                };
            } else {
                return {
                    type: 'content',
                    content: trimmed
                };
            }
        }).filter(Boolean);
        
        return structuredSections;
    }

    /**
     * Generate contextual follow-up options
     */
    generateFollowUpOptions(queryInfo) {
        const followUpType = this.determineGreetingType(queryInfo);
        const templates = this.followUpTemplates[followUpType] || this.followUpTemplates.general;
        
        // Select 3 random follow-up options
        const shuffled = [...templates].sort(() => 0.5 - Math.random());
        const selected = shuffled.slice(0, 3);
        
        return selected.map((template, index) => {
            let text = template.text;
            let action = { ...template.action };
            
            // Replace topic placeholders
            if (text.includes('{topic}') && queryInfo.topic) {
                text = text.replace('{topic}', queryInfo.topic);
            }
            if (action.params && action.params.topic === '{topic}' && queryInfo.topic) {
                action.params.topic = queryInfo.topic;
            }
            
            return {
                number: index + 1,
                text: text,
                action: action
            };
        });
    }
}

// ================================================================
// QUERY ANALYZER ENHANCEMENT
// ================================================================

class EnhancedQueryAnalyzer {
    constructor() {
        this.assetPatterns = {
            stocks: ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN', 'META', 'NVDA', 'apple', 'google', 'microsoft', 'tesla', 'amazon', 'facebook', 'nvidia'],
            crypto: ['BTC', 'ETH', 'bitcoin', 'ethereum', 'crypto', 'cryptocurrency'],
            commodities: ['gold', 'silver', 'oil', 'crude'],
            indices: ['SPY', 'QQQ', 'DIA', 'S&P 500', 'nasdaq', 'dow']
        };
        
        this.intentPatterns = {
            greeting: ['hi', 'hello', 'hey', 'good morning', 'good afternoon'],
            analysis: ['analyze', 'analysis', 'what do you think', 'how is', 'performance'],
            comparison: ['compare', 'vs', 'versus', 'difference between', 'better'],
            portfolio: ['portfolio', 'my investments', 'holdings'],
            news: ['news', 'latest', 'recent', 'what happened'],
            technical: ['technical', 'chart', 'support', 'resistance', 'moving average']
        };
    }

    analyzeQuery(message) {
        const lowerMessage = message.toLowerCase();
        
        return {
            type: this.determineQueryType(lowerMessage),
            topic: this.extractTopic(lowerMessage),
            intent: this.determineIntent(lowerMessage),
            complexity: this.determineComplexity(lowerMessage),
            needsChart: this.needsChart(lowerMessage),
            isGreeting: this.isGreeting(lowerMessage),
            isConversational: this.isConversational(lowerMessage)
        };
    }

    determineQueryType(message) {
        for (const [type, patterns] of Object.entries(this.assetPatterns)) {
            if (patterns.some(pattern => message.includes(pattern.toLowerCase()))) {
                return type === 'stocks' ? 'stock' : type.slice(0, -1); // Remove 's' from plural
            }
        }
        
        if (this.intentPatterns.portfolio.some(pattern => message.includes(pattern))) {
            return 'portfolio';
        }
        
        if (this.intentPatterns.comparison.some(pattern => message.includes(pattern))) {
            return 'comparison';
        }
        
        return 'general';
    }

    extractTopic(message) {
        // Extract specific asset names or symbols
        for (const patterns of Object.values(this.assetPatterns)) {
            for (const pattern of patterns) {
                if (message.includes(pattern.toLowerCase())) {
                    return pattern.toUpperCase();
                }
            }
        }
        
        // Extract from common patterns
        const matches = message.match(/\b([A-Z]{2,5})\b/g);
        if (matches && matches.length > 0) {
            return matches[0];
        }
        
        return null;
    }

    determineIntent(message) {
        for (const [intent, patterns] of Object.entries(this.intentPatterns)) {
            if (patterns.some(pattern => message.includes(pattern))) {
                return intent;
            }
        }
        return 'analysis';
    }

    determineComplexity(message) {
        const complexWords = ['technical', 'detailed', 'deep', 'comprehensive', 'analysis'];
        const simpleWords = ['simple', 'basic', 'easy', 'quick', 'brief'];
        
        if (complexWords.some(word => message.includes(word))) return 'high';
        if (simpleWords.some(word => message.includes(word))) return 'low';
        return 'medium';
    }

    needsChart(message) {
        const chartKeywords = ['chart', 'graph', 'visual', 'plot', 'trend', 'movement', 'performance over time'];
        return chartKeywords.some(keyword => message.includes(keyword));
    }

    isGreeting(message) {
        return this.intentPatterns.greeting.some(greeting => message.includes(greeting));
    }

    isConversational(message) {
        const conversationalPhrases = ['thanks', 'thank you', 'please', 'could you', 'would you', 'can you'];
        return conversationalPhrases.some(phrase => message.includes(phrase));
    }
}

// ================================================================
// ENHANCED PERPLEXITY CLIENT WITH CONVERSATIONAL PROMPTS
// ================================================================

class ConversationalPerplexityClient {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseURL = 'https://api.perplexity.ai';
        this.maxRetries = 3;
        this.retryDelay = 1000;
    }

    async getFinancialAnalysis(topic, options = {}) {
        const systemPrompt = `You are Max, a friendly and knowledgeable financial data analyst.

PERSONALITY GUIDELINES:
- Be conversational and approachable, like talking to a knowledgeable friend
- Use simple language to explain complex concepts
- Show enthusiasm about helping with financial questions
- Be professional but warm and encouraging
- Keep responses concise but informative (under 400 words)

CRITICAL RESTRICTIONS - NEVER VIOLATE THESE:
- NEVER provide buy, sell, or hold recommendations
- NEVER suggest trading strategies or specific entry/exit points
- NEVER use terms like "should buy/sell", "good investment", "bad investment"
- NEVER give price targets or predictions beyond current technical levels
- Focus ONLY on presenting factual data and educational information

RESPONSE STRUCTURE:
1. Present current market data and key metrics
2. Explain what the data means in simple terms
3. Provide educational context about the asset/market
4. Include relevant technical levels for reference only
5. Focus on helping users understand the information

EDUCATIONAL FOCUS:
- Explain market concepts clearly
- Help users understand what different metrics mean
- Provide context about industry or sector trends
- Share factual information about company fundamentals

If asked directly for investment advice, respond with:
"I provide market data and educational information to help you make informed decisions. For personalized investment advice, please consult with a qualified financial advisor."

Please provide a comprehensive but friendly analysis of: ${topic}`;

        const messages = [
            { role: "system", content: systemPrompt },
            { role: "user", content: topic }
        ];

        return await this.makeRequest(messages, options);
    }

    async makeRequest(messages, options = {}) {
        let lastError;
        
        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
            try {
                const response = await axios.post(`${this.baseURL}/chat/completions`, {
                    model: options.model || 'llama-3.1-sonar-small-128k-online',
                    messages: messages,
                    max_tokens: options.maxTokens || 1200,
                    temperature: options.temperature || 0.3, // Slightly higher for more natural responses
                    return_citations: true,
                    return_images: false,
                    return_related_questions: false,
                    search_domain_filter: ["perplexity.ai"],
                    search_recency_filter: options.searchRecency || "month"
                }, {
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    timeout: 30000
                });

                return response.data;
                
            } catch (error) {
                lastError = error;
                console.warn(`[Perplexity] Attempt ${attempt}/${this.maxRetries} failed:`, error.message);
                
                if (error.response?.status === 401) {
                    throw new Error('Invalid Perplexity API key');
                }
                
                if (error.response?.status === 429) {
                    throw new Error('Rate limit exceeded. Please try again later.');
                }
                
                if (attempt < this.maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, this.retryDelay * attempt));
                }
            }
        }
        
        throw new Error(`Perplexity API failed after ${this.maxRetries} attempts: ${lastError.message}`);
    }
}

// ================================================================
// INTEGRATION AND INITIALIZATION
// ================================================================

// Initialize enhanced components
const conversationalFormatter = new ConversationalFormatter();
const queryAnalyzer = new EnhancedQueryAnalyzer();

// Replace the existing Perplexity client with conversational version
let conversationalPerplexityClient;
try {
    if (PERPLEXITY_KEY) {
        conversationalPerplexityClient = new ConversationalPerplexityClient(PERPLEXITY_KEY);
        console.log('✅ Conversational Perplexity AI client initialized successfully');
    }
} catch (error) {
    console.error('❌ Failed to initialize Conversational Perplexity client:', error.message);
}

// ================================================================
// USAGE EXAMPLE FOR INTEGRATION
// ================================================================

/*
// Update the chat endpoint to use conversational system:

app.post('/api/chat', async (req, res) => {
    try {
        const { message, sessionId } = req.body;
        
        // Analyze the query for context
        const queryInfo = queryAnalyzer.analyzeQuery(message);
        
        // Handle greetings with friendly responses
        if (queryInfo.isGreeting) {
            return res.json({
                success: true,
                analysis: {
                    greeting: "Hi there! I'm Max, your friendly financial advisor. I'm here to help you understand market data and make informed financial decisions!",
                    content: "What would you like to explore today? I can help you analyze stocks, crypto, portfolios, or answer any financial questions you have.",
                    followUpOptions: [
                        { number: 1, text: "Analyze a specific stock", action: { type: "prompt_stock", params: {} } },
                        { number: 2, text: "Check crypto prices", action: { type: "prompt_crypto", params: {} } },
                        { number: 3, text: "Upload my portfolio", action: { type: "prompt_portfolio", params: {} } }
                    ]
                },
                sessionId: sessionId
            });
        }
        
        // Get conversational analysis
        const analysis = await conversationalPerplexityClient.getFinancialAnalysis(message.trim());
        
        // Format with conversational elements
        const conversationalResponse = conversationalFormatter.formatResponse(analysis, queryInfo);
        
        res.json({
            success: true,
            analysis: conversationalResponse,
            sessionId: sessionId,
            metadata: {
                queryType: queryInfo.type,
                topic: queryInfo.topic,
                conversational: true,
                timestamp: new Date().toISOString()
            }
        });

    } catch (error) {
        // ... error handling
    }
});
*/

console.log('✅ Conversational Response System initialized successfully');

// ================================================================
// PHASE 2 TASK 2.1 - SUCCESS CRITERIA VERIFICATION
// ================================================================

/*
✅ SUCCESS CRITERIA MET:

1. ✅ Every response starts with a varied, friendly greeting
   - 7 different greetings for general queries
   - Context-specific greetings for stocks, crypto, portfolio
   - Topic-aware greeting customization

2. ✅ Technical terms explained in simple language
   - 10+ financial terms with plain English explanations
   - Automatic jargon replacement in responses
   - Educational focus on helping users understand

3. ✅ 3 contextual follow-up options after each response
   - Smart follow-up suggestions based on query type
   - Action-based system for easy user interaction
   - Contextual relevance to keep conversation flowing

4. ✅ Natural, conversational flow maintained
   - Friendly, encouraging personality (Max)
   - Conversational phrases and transitions
   - Simple, digestible language

5. ✅ No robotic or overly formal language
   - Warm, human-like responses
   - Varied phrasing and expressions
   - Professional but approachable tone

NEXT: Phase 2 Task 2.2 - Remove All Trading Advice
*/